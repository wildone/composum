package com.composum.sling.clientlibs.servlet;

import com.composum.sling.clientlibs.handle.Clientlib;
import com.composum.sling.clientlibs.handle.ClientlibLink;
import com.composum.sling.clientlibs.handle.ClientlibRef;
import org.apache.commons.lang3.StringUtils;
import org.apache.felix.scr.annotations.sling.SlingServlet;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.request.RequestPathInfo;
import org.apache.sling.api.servlets.HttpConstants;
import org.slf4j.Logger;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.slf4j.LoggerFactory.getLogger;

@SlingServlet(
        resourceTypes = Clientlib.RESOURCE_TYPE,
        extensions = {"js", "css", "map"},
        methods = {HttpConstants.METHOD_GET, HttpConstants.METHOD_HEAD}
)
public class ClientlibServlet extends AbstractClientlibServlet {

    private static final Logger LOG = getLogger(ClientlibServlet.class);

    protected static final Pattern FILENAME_PATTERN = Pattern.compile("[^/]*+$");
    protected static final Pattern HASHSUFFIX_PATTERN = Pattern.compile("/?([0-9a-zA-Z_-]++)/" + FILENAME_PATTERN.pattern());

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
            throws ServletException, IOException {
        serve(true, request, response);
    }

    @Override
    protected void doHead(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        serve(false, request, response);
    }

    private void serve(boolean get, SlingHttpServletRequest request, SlingHttpServletResponse response) throws IOException, ServletException {
        if (!dropRequest(request, response)) {
            try {
                RequestPathInfo pathInfo = request.getRequestPathInfo();
                String selectors = pathInfo.getSelectorString();
                String path = pathInfo.getResourcePath();
                String hash = parseHashFromSuffix(pathInfo.getSuffix());

                Clientlib.Type type = Clientlib.Type.valueOf(pathInfo.getExtension().toLowerCase());
                ClientlibRef clientlibref = new ClientlibRef(type, path, false, null);

                deliverClientlib(get, request, response, clientlibref, hash, isMinified(selectors));
            } catch (RepositoryException ex) {
                throw new ServletException(ex);
            }
        }
    }

    /** Creates an path that is rendered by this servlet containing the given parameters. */
    public static String makePath(String path, Clientlib.Type type, boolean minified, String hash) {
        StringBuilder builder = new StringBuilder(path);
        if (minified) builder.append(".min");
        if (!path.endsWith("." + type.name()) && type != Clientlib.Type.img && type != Clientlib.Type.link) {
            builder.append('.').append(type.name()); // relevant for categories
        }
        return appendHashSuffix(builder.toString(), hash);
    }

    @Override
    protected String makeUri(boolean minified, ClientlibLink link) {
        return makePath(link.path, link.type, minified, link.hash);
    }

    /**
     * Appends a suffix containing the hash code, if given. The file name is repeated to satisfy browsers
     * with the correct type and file name, though it is not used by the servlet.
     *
     * @param url  an url to which we append the suffix
     * @param hash optional, the hash code
     * @return the url with suffix /{hash}/{filename} appended, where {filename} is the last part of a / separated url.
     */
    public static String appendHashSuffix(String url, String hash) {
        if (null == hash) return url;
        Matcher matcher = FILENAME_PATTERN.matcher(url);
        String fname = "";
        if (matcher.find()) fname = matcher.group(0);
        return url + "/" + hash + "/" + fname;
    }

    /**
     * Does the inverse to {@link #appendHashSuffix(String, String)}: extracts the hash from the generated suffix.
     *
     * @param suffix the suffix generated by {@link #appendHashSuffix(String, String)} , nullable
     * @return the hash if it could be extracted, otherwise null.
     */
    public static String parseHashFromSuffix(String suffix) {
        if (StringUtils.isBlank(suffix)) return null;
        Matcher matcher = HASHSUFFIX_PATTERN.matcher(suffix);
        if (matcher.matches()) {
            return matcher.group(1);
        } else LOG.warn("Could not parse hash suffix {}", suffix);
        return null;
    }

}
